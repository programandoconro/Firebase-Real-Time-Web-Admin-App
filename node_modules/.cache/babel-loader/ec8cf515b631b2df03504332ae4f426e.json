{"ast":null,"code":"import { __awaiter, __generator, __spreadArrays } from \"tslib\";\nimport { r as registerInstance, d as createEvent, e as getElement, c as getIonMode, h, H as Host } from './core-feeeff0d.js';\nimport './config-3c7f3790.js';\nimport { e as debounce } from './helpers-46f4a262.js';\nimport { o as openURL, c as createColorClasses } from './theme-18cbe2cc.js';\n\nvar Route =\n/** @class */\nfunction () {\n  function Route(hostRef) {\n    registerInstance(this, hostRef);\n    /**\n     * Relative path that needs to match in order for this route to apply.\n     *\n     * Accepts paths similar to expressjs so that you can define parameters\n     * in the url /foo/:bar where bar would be available in incoming props.\n     */\n\n    this.url = '';\n    this.ionRouteDataChanged = createEvent(this, \"ionRouteDataChanged\", 7);\n  }\n\n  Route.prototype.onUpdate = function (newValue) {\n    this.ionRouteDataChanged.emit(newValue);\n  };\n\n  Route.prototype.onComponentProps = function (newValue, oldValue) {\n    if (newValue === oldValue) {\n      return;\n    }\n\n    var keys1 = newValue ? Object.keys(newValue) : [];\n    var keys2 = oldValue ? Object.keys(oldValue) : [];\n\n    if (keys1.length !== keys2.length) {\n      this.onUpdate(newValue);\n      return;\n    }\n\n    for (var _i = 0, keys1_1 = keys1; _i < keys1_1.length; _i++) {\n      var key = keys1_1[_i];\n\n      if (newValue[key] !== oldValue[key]) {\n        this.onUpdate(newValue);\n        return;\n      }\n    }\n  };\n\n  Route.prototype.connectedCallback = function () {\n    this.ionRouteDataChanged.emit();\n  };\n\n  Object.defineProperty(Route, \"watchers\", {\n    get: function get() {\n      return {\n        \"url\": [\"onUpdate\"],\n        \"component\": [\"onUpdate\"],\n        \"componentProps\": [\"onComponentProps\"]\n      };\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return Route;\n}();\n\nvar RouteRedirect =\n/** @class */\nfunction () {\n  function RouteRedirect(hostRef) {\n    registerInstance(this, hostRef);\n    this.ionRouteRedirectChanged = createEvent(this, \"ionRouteRedirectChanged\", 7);\n  }\n\n  RouteRedirect.prototype.propDidChange = function () {\n    this.ionRouteRedirectChanged.emit();\n  };\n\n  RouteRedirect.prototype.connectedCallback = function () {\n    this.ionRouteRedirectChanged.emit();\n  };\n\n  Object.defineProperty(RouteRedirect, \"watchers\", {\n    get: function get() {\n      return {\n        \"from\": [\"propDidChange\"],\n        \"to\": [\"propDidChange\"]\n      };\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return RouteRedirect;\n}();\n\nvar ROUTER_INTENT_NONE = 'root';\nvar ROUTER_INTENT_FORWARD = 'forward';\nvar ROUTER_INTENT_BACK = 'back';\n\nvar generatePath = function generatePath(segments) {\n  var path = segments.filter(function (s) {\n    return s.length > 0;\n  }).join('/');\n  return '/' + path;\n};\n\nvar chainToPath = function chainToPath(chain) {\n  var path = [];\n\n  for (var _i = 0, chain_1 = chain; _i < chain_1.length; _i++) {\n    var route = chain_1[_i];\n\n    for (var _a = 0, _b = route.path; _a < _b.length; _a++) {\n      var segment = _b[_a];\n\n      if (segment[0] === ':') {\n        var param = route.params && route.params[segment.slice(1)];\n\n        if (!param) {\n          return null;\n        }\n\n        path.push(param);\n      } else if (segment !== '') {\n        path.push(segment);\n      }\n    }\n  }\n\n  return path;\n};\n\nvar writePath = function writePath(history, root, useHash, path, direction, state) {\n  var url = generatePath(__spreadArrays(parsePath(root), path));\n\n  if (useHash) {\n    url = '#' + url;\n  }\n\n  if (direction === ROUTER_INTENT_FORWARD) {\n    history.pushState(state, '', url);\n  } else {\n    history.replaceState(state, '', url);\n  }\n};\n\nvar removePrefix = function removePrefix(prefix, path) {\n  if (prefix.length > path.length) {\n    return null;\n  }\n\n  if (prefix.length <= 1 && prefix[0] === '') {\n    return path;\n  }\n\n  for (var i = 0; i < prefix.length; i++) {\n    if (prefix[i].length > 0 && prefix[i] !== path[i]) {\n      return null;\n    }\n  }\n\n  if (path.length === prefix.length) {\n    return [''];\n  }\n\n  return path.slice(prefix.length);\n};\n\nvar readPath = function readPath(loc, root, useHash) {\n  var pathname = loc.pathname;\n\n  if (useHash) {\n    var hash = loc.hash;\n    pathname = hash[0] === '#' ? hash.slice(1) : '';\n  }\n\n  var prefix = parsePath(root);\n  var path = parsePath(pathname);\n  return removePrefix(prefix, path);\n};\n\nvar parsePath = function parsePath(path) {\n  if (path == null) {\n    return [''];\n  }\n\n  var segments = path.split('/').map(function (s) {\n    return s.trim();\n  }).filter(function (s) {\n    return s.length > 0;\n  });\n\n  if (segments.length === 0) {\n    return [''];\n  } else {\n    return segments;\n  }\n};\n\nvar printRoutes = function printRoutes(routes) {\n  console.group(\"[ion-core] ROUTES[\" + routes.length + \"]\");\n\n  var _loop_1 = function _loop_1(chain) {\n    var path = [];\n    chain.forEach(function (r) {\n      return path.push.apply(path, r.path);\n    });\n    var ids = chain.map(function (r) {\n      return r.id;\n    });\n    console.debug(\"%c \" + generatePath(path), 'font-weight: bold; padding-left: 20px', '=>\\t', \"(\" + ids.join(', ') + \")\");\n  };\n\n  for (var _i = 0, routes_1 = routes; _i < routes_1.length; _i++) {\n    var chain = routes_1[_i];\n\n    _loop_1(chain);\n  }\n\n  console.groupEnd();\n};\n\nvar printRedirects = function printRedirects(redirects) {\n  console.group(\"[ion-core] REDIRECTS[\" + redirects.length + \"]\");\n\n  for (var _i = 0, redirects_1 = redirects; _i < redirects_1.length; _i++) {\n    var redirect = redirects_1[_i];\n\n    if (redirect.to) {\n      console.debug('FROM: ', \"$c \" + generatePath(redirect.from), 'font-weight: bold', ' TO: ', \"$c \" + generatePath(redirect.to), 'font-weight: bold');\n    }\n  }\n\n  console.groupEnd();\n};\n\nvar writeNavState = function writeNavState(root, chain, direction, index, changed) {\n  if (changed === void 0) {\n    changed = false;\n  }\n\n  return __awaiter(void 0, void 0, void 0, function () {\n    var outlet, route, result, e_1;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          _a.trys.push([0, 6,, 7]);\n\n          outlet = searchNavNode(root); // make sure we can continue interacting the DOM, otherwise abort\n\n          if (index >= chain.length || !outlet) {\n            return [2\n            /*return*/\n            , changed];\n          }\n\n          return [4\n          /*yield*/\n          , outlet.componentOnReady()];\n\n        case 1:\n          _a.sent();\n\n          route = chain[index];\n          return [4\n          /*yield*/\n          , outlet.setRouteId(route.id, route.params, direction)];\n\n        case 2:\n          result = _a.sent(); // if the outlet changed the page, reset navigation to neutral (no direction)\n          // this means nested outlets will not animate\n\n          if (result.changed) {\n            direction = ROUTER_INTENT_NONE;\n            changed = true;\n          }\n\n          return [4\n          /*yield*/\n          , writeNavState(result.element, chain, direction, index + 1, changed)];\n\n        case 3:\n          // recursively set nested outlets\n          changed = _a.sent();\n          if (!result.markVisible) return [3\n          /*break*/\n          , 5];\n          return [4\n          /*yield*/\n          , result.markVisible()];\n\n        case 4:\n          _a.sent();\n\n          _a.label = 5;\n\n        case 5:\n          return [2\n          /*return*/\n          , changed];\n\n        case 6:\n          e_1 = _a.sent();\n          console.error(e_1);\n          return [2\n          /*return*/\n          , false];\n\n        case 7:\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  });\n};\n\nvar readNavState = function readNavState(root) {\n  return __awaiter(void 0, void 0, void 0, function () {\n    var ids, outlet, node, id;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          ids = [];\n          node = root;\n          _a.label = 1;\n\n        case 1:\n          if (!true) return [3\n          /*break*/\n          , 5];\n          outlet = searchNavNode(node);\n          if (!outlet) return [3\n          /*break*/\n          , 3];\n          return [4\n          /*yield*/\n          , outlet.getRouteId()];\n\n        case 2:\n          id = _a.sent();\n\n          if (id) {\n            node = id.element;\n            id.element = undefined;\n            ids.push(id);\n          } else {\n            return [3\n            /*break*/\n            , 5];\n          }\n\n          return [3\n          /*break*/\n          , 4];\n\n        case 3:\n          return [3\n          /*break*/\n          , 5];\n\n        case 4:\n          return [3\n          /*break*/\n          , 1];\n\n        case 5:\n          return [2\n          /*return*/\n          , {\n            ids: ids,\n            outlet: outlet\n          }];\n      }\n    });\n  });\n};\n\nvar waitUntilNavNode = function waitUntilNavNode() {\n  if (searchNavNode(document.body)) {\n    return Promise.resolve();\n  }\n\n  return new Promise(function (resolve) {\n    window.addEventListener('ionNavWillLoad', resolve, {\n      once: true\n    });\n  });\n};\n\nvar QUERY = ':not([no-router]) ion-nav, :not([no-router]) ion-tabs, :not([no-router]) ion-router-outlet';\n\nvar searchNavNode = function searchNavNode(root) {\n  if (!root) {\n    return undefined;\n  }\n\n  if (root.matches(QUERY)) {\n    return root;\n  }\n\n  var outlet = root.querySelector(QUERY);\n  return outlet ? outlet : undefined;\n};\n\nvar matchesRedirect = function matchesRedirect(input, route) {\n  var from = route.from,\n      to = route.to;\n\n  if (to === undefined) {\n    return false;\n  }\n\n  if (from.length > input.length) {\n    return false;\n  }\n\n  for (var i = 0; i < from.length; i++) {\n    var expected = from[i];\n\n    if (expected === '*') {\n      return true;\n    }\n\n    if (expected !== input[i]) {\n      return false;\n    }\n  }\n\n  return from.length === input.length;\n};\n\nvar routeRedirect = function routeRedirect(path, routes) {\n  return routes.find(function (route) {\n    return matchesRedirect(path, route);\n  });\n};\n\nvar matchesIDs = function matchesIDs(ids, chain) {\n  var len = Math.min(ids.length, chain.length);\n  var i = 0;\n\n  for (; i < len; i++) {\n    if (ids[i].toLowerCase() !== chain[i].id) {\n      break;\n    }\n  }\n\n  return i;\n};\n\nvar matchesPath = function matchesPath(inputPath, chain) {\n  var segments = new RouterSegments(inputPath);\n  var matchesDefault = false;\n  var allparams;\n\n  for (var i = 0; i < chain.length; i++) {\n    var path = chain[i].path;\n\n    if (path[0] === '') {\n      matchesDefault = true;\n    } else {\n      for (var _i = 0, path_1 = path; _i < path_1.length; _i++) {\n        var segment = path_1[_i];\n        var data = segments.next(); // data param\n\n        if (segment[0] === ':') {\n          if (data === '') {\n            return null;\n          }\n\n          allparams = allparams || [];\n          var params = allparams[i] || (allparams[i] = {});\n          params[segment.slice(1)] = data;\n        } else if (data !== segment) {\n          return null;\n        }\n      }\n\n      matchesDefault = false;\n    }\n  }\n\n  var matches = matchesDefault ? matchesDefault === (segments.next() === '') : true;\n\n  if (!matches) {\n    return null;\n  }\n\n  if (allparams) {\n    return chain.map(function (route, i) {\n      return {\n        id: route.id,\n        path: route.path,\n        params: mergeParams(route.params, allparams[i])\n      };\n    });\n  }\n\n  return chain;\n};\n\nvar mergeParams = function mergeParams(a, b) {\n  if (!a && b) {\n    return b;\n  } else if (a && !b) {\n    return a;\n  } else if (a && b) {\n    return Object.assign(Object.assign({}, a), b);\n  }\n\n  return undefined;\n};\n\nvar routerIDsToChain = function routerIDsToChain(ids, chains) {\n  var match = null;\n  var maxMatches = 0;\n  var plainIDs = ids.map(function (i) {\n    return i.id;\n  });\n\n  for (var _i = 0, chains_1 = chains; _i < chains_1.length; _i++) {\n    var chain = chains_1[_i];\n    var score = matchesIDs(plainIDs, chain);\n\n    if (score > maxMatches) {\n      match = chain;\n      maxMatches = score;\n    }\n  }\n\n  if (match) {\n    return match.map(function (route, i) {\n      return {\n        id: route.id,\n        path: route.path,\n        params: mergeParams(route.params, ids[i] && ids[i].params)\n      };\n    });\n  }\n\n  return null;\n};\n\nvar routerPathToChain = function routerPathToChain(path, chains) {\n  var match = null;\n  var matches = 0;\n\n  for (var _i = 0, chains_2 = chains; _i < chains_2.length; _i++) {\n    var chain = chains_2[_i];\n    var matchedChain = matchesPath(path, chain);\n\n    if (matchedChain !== null) {\n      var score = computePriority(matchedChain);\n\n      if (score > matches) {\n        matches = score;\n        match = matchedChain;\n      }\n    }\n  }\n\n  return match;\n};\n\nvar computePriority = function computePriority(chain) {\n  var score = 1;\n  var level = 1;\n\n  for (var _i = 0, chain_2 = chain; _i < chain_2.length; _i++) {\n    var route = chain_2[_i];\n\n    for (var _a = 0, _b = route.path; _a < _b.length; _a++) {\n      var path = _b[_a];\n\n      if (path[0] === ':') {\n        score += Math.pow(1, level);\n      } else if (path !== '') {\n        score += Math.pow(2, level);\n      }\n\n      level++;\n    }\n  }\n\n  return score;\n};\n\nvar RouterSegments =\n/** @class */\nfunction () {\n  function RouterSegments(path) {\n    this.path = path.slice();\n  }\n\n  RouterSegments.prototype.next = function () {\n    if (this.path.length > 0) {\n      return this.path.shift();\n    }\n\n    return '';\n  };\n\n  return RouterSegments;\n}();\n\nvar readRedirects = function readRedirects(root) {\n  return Array.from(root.children).filter(function (el) {\n    return el.tagName === 'ION-ROUTE-REDIRECT';\n  }).map(function (el) {\n    var to = readProp(el, 'to');\n    return {\n      from: parsePath(readProp(el, 'from')),\n      to: to == null ? undefined : parsePath(to)\n    };\n  });\n};\n\nvar readRoutes = function readRoutes(root) {\n  return flattenRouterTree(readRouteNodes(root));\n};\n\nvar readRouteNodes = function readRouteNodes(root, node) {\n  if (node === void 0) {\n    node = root;\n  }\n\n  return Array.from(node.children).filter(function (el) {\n    return el.tagName === 'ION-ROUTE' && el.component;\n  }).map(function (el) {\n    var component = readProp(el, 'component');\n\n    if (component == null) {\n      throw new Error('component missing in ion-route');\n    }\n\n    return {\n      path: parsePath(readProp(el, 'url')),\n      id: component.toLowerCase(),\n      params: el.componentProps,\n      children: readRouteNodes(root, el)\n    };\n  });\n};\n\nvar readProp = function readProp(el, prop) {\n  if (prop in el) {\n    return el[prop];\n  }\n\n  if (el.hasAttribute(prop)) {\n    return el.getAttribute(prop);\n  }\n\n  return null;\n};\n\nvar flattenRouterTree = function flattenRouterTree(nodes) {\n  var routes = [];\n\n  for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {\n    var node = nodes_1[_i];\n    flattenNode([], routes, node);\n  }\n\n  return routes;\n};\n\nvar flattenNode = function flattenNode(chain, routes, node) {\n  var s = chain.slice();\n  s.push({\n    id: node.id,\n    path: node.path,\n    params: node.params\n  });\n\n  if (node.children.length === 0) {\n    routes.push(s);\n    return;\n  }\n\n  for (var _i = 0, _a = node.children; _i < _a.length; _i++) {\n    var sub = _a[_i];\n    flattenNode(s, routes, sub);\n  }\n};\n\nvar Router =\n/** @class */\nfunction () {\n  function class_1(hostRef) {\n    registerInstance(this, hostRef);\n    this.previousPath = null;\n    this.busy = false;\n    this.state = 0;\n    this.lastState = 0;\n    /**\n     * By default `ion-router` will match the routes at the root path (\"/\").\n     * That can be changed when\n     *\n     */\n\n    this.root = '/';\n    /**\n     * The router can work in two \"modes\":\n     * - With hash: `/index.html#/path/to/page`\n     * - Without hash: `/path/to/page`\n     *\n     * Using one or another might depend in the requirements of your app and/or where it's deployed.\n     *\n     * Usually \"hash-less\" navigation works better for SEO and it's more user friendly too, but it might\n     * requires additional server-side configuration in order to properly work.\n     *\n     * On the otherside hash-navigation is much easier to deploy, it even works over the file protocol.\n     *\n     * By default, this property is `true`, change to `false` to allow hash-less URLs.\n     */\n\n    this.useHash = true;\n    this.ionRouteWillChange = createEvent(this, \"ionRouteWillChange\", 7);\n    this.ionRouteDidChange = createEvent(this, \"ionRouteDidChange\", 7);\n  }\n\n  class_1.prototype.componentWillLoad = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            console.debug('[ion-router] router will load');\n            return [4\n            /*yield*/\n            , waitUntilNavNode()];\n\n          case 1:\n            _a.sent();\n\n            console.debug('[ion-router] found nav');\n            return [4\n            /*yield*/\n            , this.onRoutesChanged()];\n\n          case 2:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  class_1.prototype.componentDidLoad = function () {\n    window.addEventListener('ionRouteRedirectChanged', debounce(this.onRedirectChanged.bind(this), 10));\n    window.addEventListener('ionRouteDataChanged', debounce(this.onRoutesChanged.bind(this), 100));\n  };\n\n  class_1.prototype.onPopState = function () {\n    var direction = this.historyDirection();\n    var path = this.getPath();\n    console.debug('[ion-router] URL changed -> update nav', path, direction);\n    return this.writeNavStateRoot(path, direction);\n  };\n\n  class_1.prototype.onBackButton = function (ev) {\n    var _this = this;\n\n    ev.detail.register(0, function () {\n      return _this.back();\n    });\n  };\n  /**\n   * Navigate to the specified URL.\n   *\n   * @param url The url to navigate to.\n   * @param direction The direction of the animation. Defaults to `\"forward\"`.\n   */\n\n\n  class_1.prototype.push = function (url, direction) {\n    if (direction === void 0) {\n      direction = 'forward';\n    }\n\n    if (url.startsWith('.')) {\n      url = new URL(url, window.location.href).pathname;\n    }\n\n    console.debug('[ion-router] URL pushed -> updating nav', url, direction);\n    var path = parsePath(url);\n    this.setPath(path, direction);\n    return this.writeNavStateRoot(path, direction);\n  };\n  /**\n   * Go back to previous page in the window.history.\n   */\n\n\n  class_1.prototype.back = function () {\n    window.history.back();\n    return Promise.resolve(this.waitPromise);\n  };\n  /** @internal */\n\n\n  class_1.prototype.printDebug = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        console.debug('CURRENT PATH', this.getPath());\n        console.debug('PREVIOUS PATH', this.previousPath);\n        printRoutes(readRoutes(this.el));\n        printRedirects(readRedirects(this.el));\n        return [2\n        /*return*/\n        ];\n      });\n    });\n  };\n  /** @internal */\n\n\n  class_1.prototype.navChanged = function (direction) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, ids, outlet, routes, chain, path;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (this.busy) {\n              console.warn('[ion-router] router is busy, navChanged was cancelled');\n              return [2\n              /*return*/\n              , false];\n            }\n\n            return [4\n            /*yield*/\n            , readNavState(window.document.body)];\n\n          case 1:\n            _a = _b.sent(), ids = _a.ids, outlet = _a.outlet;\n            routes = readRoutes(this.el);\n            chain = routerIDsToChain(ids, routes);\n\n            if (!chain) {\n              console.warn('[ion-router] no matching URL for ', ids.map(function (i) {\n                return i.id;\n              }));\n              return [2\n              /*return*/\n              , false];\n            }\n\n            path = chainToPath(chain);\n\n            if (!path) {\n              console.warn('[ion-router] router could not match path because some required param is missing');\n              return [2\n              /*return*/\n              , false];\n            }\n\n            console.debug('[ion-router] nav changed -> update URL', ids, path);\n            this.setPath(path, direction);\n            return [4\n            /*yield*/\n            , this.safeWriteNavState(outlet, chain, ROUTER_INTENT_NONE, path, null, ids.length)];\n\n          case 2:\n            _b.sent();\n\n            return [2\n            /*return*/\n            , true];\n        }\n      });\n    });\n  };\n\n  class_1.prototype.onRedirectChanged = function () {\n    var path = this.getPath();\n\n    if (path && routeRedirect(path, readRedirects(this.el))) {\n      this.writeNavStateRoot(path, ROUTER_INTENT_NONE);\n    }\n  };\n\n  class_1.prototype.onRoutesChanged = function () {\n    return this.writeNavStateRoot(this.getPath(), ROUTER_INTENT_NONE);\n  };\n\n  class_1.prototype.historyDirection = function () {\n    var win = window;\n\n    if (win.history.state === null) {\n      this.state++;\n      win.history.replaceState(this.state, win.document.title, win.document.location && win.document.location.href);\n    }\n\n    var state = win.history.state;\n    var lastState = this.lastState;\n    this.lastState = state;\n\n    if (state > lastState) {\n      return ROUTER_INTENT_FORWARD;\n    } else if (state < lastState) {\n      return ROUTER_INTENT_BACK;\n    } else {\n      return ROUTER_INTENT_NONE;\n    }\n  };\n\n  class_1.prototype.writeNavStateRoot = function (path, direction) {\n    return __awaiter(this, void 0, void 0, function () {\n      var redirects, redirect, redirectFrom, routes, chain;\n      return __generator(this, function (_a) {\n        if (!path) {\n          console.error('[ion-router] URL is not part of the routing set');\n          return [2\n          /*return*/\n          , false];\n        }\n\n        redirects = readRedirects(this.el);\n        redirect = routeRedirect(path, redirects);\n        redirectFrom = null;\n\n        if (redirect) {\n          this.setPath(redirect.to, direction);\n          redirectFrom = redirect.from;\n          path = redirect.to;\n        }\n\n        routes = readRoutes(this.el);\n        chain = routerPathToChain(path, routes);\n\n        if (!chain) {\n          console.error('[ion-router] the path does not match any route');\n          return [2\n          /*return*/\n          , false];\n        } // write DOM give\n\n\n        return [2\n        /*return*/\n        , this.safeWriteNavState(document.body, chain, direction, path, redirectFrom)];\n      });\n    });\n  };\n\n  class_1.prototype.safeWriteNavState = function (node, chain, direction, path, redirectFrom, index) {\n    if (index === void 0) {\n      index = 0;\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var unlock, changed, e_2;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.lock()];\n\n          case 1:\n            unlock = _a.sent();\n            changed = false;\n            _a.label = 2;\n\n          case 2:\n            _a.trys.push([2, 4,, 5]);\n\n            return [4\n            /*yield*/\n            , this.writeNavState(node, chain, direction, path, redirectFrom, index)];\n\n          case 3:\n            changed = _a.sent();\n            return [3\n            /*break*/\n            , 5];\n\n          case 4:\n            e_2 = _a.sent();\n            console.error(e_2);\n            return [3\n            /*break*/\n            , 5];\n\n          case 5:\n            unlock();\n            return [2\n            /*return*/\n            , changed];\n        }\n      });\n    });\n  };\n\n  class_1.prototype.lock = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var p, resolve;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            p = this.waitPromise;\n            this.waitPromise = new Promise(function (r) {\n              return resolve = r;\n            });\n            if (!(p !== undefined)) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , p];\n\n          case 1:\n            _a.sent();\n\n            _a.label = 2;\n\n          case 2:\n            return [2\n            /*return*/\n            , resolve];\n        }\n      });\n    });\n  };\n\n  class_1.prototype.writeNavState = function (node, chain, direction, path, redirectFrom, index) {\n    if (index === void 0) {\n      index = 0;\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var routeEvent, changed;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (this.busy) {\n              console.warn('[ion-router] router is busy, transition was cancelled');\n              return [2\n              /*return*/\n              , false];\n            }\n\n            this.busy = true;\n            routeEvent = this.routeChangeEvent(path, redirectFrom);\n\n            if (routeEvent) {\n              this.ionRouteWillChange.emit(routeEvent);\n            }\n\n            return [4\n            /*yield*/\n            , writeNavState(node, chain, direction, index)];\n\n          case 1:\n            changed = _a.sent();\n            this.busy = false;\n\n            if (changed) {\n              console.debug('[ion-router] route changed', path);\n            } // emit did change\n\n\n            if (routeEvent) {\n              this.ionRouteDidChange.emit(routeEvent);\n            }\n\n            return [2\n            /*return*/\n            , changed];\n        }\n      });\n    });\n  };\n\n  class_1.prototype.setPath = function (path, direction) {\n    this.state++;\n    writePath(window.history, this.root, this.useHash, path, direction, this.state);\n  };\n\n  class_1.prototype.getPath = function () {\n    return readPath(window.location, this.root, this.useHash);\n  };\n\n  class_1.prototype.routeChangeEvent = function (path, redirectFromPath) {\n    var from = this.previousPath;\n    var to = generatePath(path);\n    this.previousPath = to;\n\n    if (to === from) {\n      return null;\n    }\n\n    var redirectedFrom = redirectFromPath ? generatePath(redirectFromPath) : null;\n    return {\n      from: from,\n      redirectedFrom: redirectedFrom,\n      to: to\n    };\n  };\n\n  Object.defineProperty(class_1.prototype, \"el\", {\n    get: function get() {\n      return getElement(this);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return class_1;\n}();\n\nvar RouterLink =\n/** @class */\nfunction () {\n  function RouterLink(hostRef) {\n    var _this = this;\n\n    registerInstance(this, hostRef);\n    /**\n     * When using a router, it specifies the transition direction when navigating to\n     * another page using `href`.\n     */\n\n    this.routerDirection = 'forward';\n\n    this.onClick = function (ev) {\n      openURL(_this.href, ev, _this.routerDirection);\n    };\n  }\n\n  RouterLink.prototype.render = function () {\n    var _a;\n\n    var mode = getIonMode(this);\n    var attrs = {\n      href: this.href,\n      rel: this.rel,\n      target: this.target\n    };\n    return h(Host, {\n      onClick: this.onClick,\n      class: Object.assign(Object.assign({}, createColorClasses(this.color)), (_a = {}, _a[mode] = true, _a['ion-activatable'] = true, _a))\n    }, h(\"a\", Object.assign({}, attrs), h(\"slot\", null)));\n  };\n\n  Object.defineProperty(RouterLink, \"style\", {\n    get: function get() {\n      return \":host{--background:transparent;--color:var(--ion-color-primary,#3880ff);background:var(--background);color:var(--color)}:host(.ion-color){color:var(--ion-color-base)}a{font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit}\";\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return RouterLink;\n}();\n\nexport { Route as ion_route, RouteRedirect as ion_route_redirect, Router as ion_router, RouterLink as ion_router_link };","map":null,"metadata":{},"sourceType":"module"}